// Code generated by protoc-gen-go-kiwi. DO NOT EDIT.

package user

import (
	"game/proto/pb"
	"github.com/15mga/kiwi/util/mgo"
	"go.mongodb.org/mongo-driver/bson"
	"sync"
)

func initModels() {
	initModelFac()
	initEvict()
}

var _ModelFac map[string]func() mgo.IModel

func initModelFac() {
	_ModelFac = map[string]func() mgo.IModel{
		SchemaMobileAccount: NewMobileAccount,
		SchemaEmailAccount:  NewEmailAccount,
		SchemaWechatAccount: NewWechatAccount,
		SchemaUser:          NewUser,
	}
}

func initEvict() {
	mgo.BindEvict(SchemaMobileAccount, onMobileAccountEvict)
	mgo.BindEvict(SchemaEmailAccount, onEmailAccountEvict)
	mgo.BindEvict(SchemaWechatAccount, onWechatAccountEvict)
	mgo.BindEvict(SchemaUser, onUserEvict)
}

var ()

func SetMobileAccount(m *MobileAccount) {
	mgo.SetModel(m)
}

func DelMobileAccount(id string) {
	m, ok := mgo.GetModel[*MobileAccount](SchemaMobileAccount, id)
	if !ok {
		return
	}
	mgo.DelModel(SchemaMobileAccount, id)
	delMobileAccountMap(m)
}

func onMobileAccountEvict(model mgo.IModel) {
	delMobileAccountMap(model.(*MobileAccount))
}

func delMobileAccountMap(m *MobileAccount) {
}

func GetMobileAccountWithId(id string) (*MobileAccount, error) {
	m, ok := mgo.GetModel[*MobileAccount](SchemaMobileAccount, id)
	if ok {
		return m, nil
	}
	m = _ModelFac[SchemaMobileAccount]().(*MobileAccount)
	err := mgo.FindOne(SchemaMobileAccount, bson.M{"_id": id}, m.MobileAccount)
	if err != nil {
		return nil, err
	}
	SetMobileAccount(m)
	return m, nil
}

type MobileAccount struct {
	*pb.MobileAccount
}

func (this *MobileAccount) SetPassword(val string) {
	this.Password = val
	mgo.ModelWriter().Write(SchemaMobileAccount, this.Id, bson.M{MobileAccountPassword: val})
}

func (this *MobileAccount) SetUserId(val string) {
	this.UserId = val
	mgo.ModelWriter().Write(SchemaMobileAccount, this.Id, bson.M{MobileAccountUserId: val})
}

func NewMobileAccount() mgo.IModel {
	m := &MobileAccount{
		MobileAccount: &pb.MobileAccount{},
	}
	return m
}

func InsertMobileAccount(data *pb.MobileAccount) (*MobileAccount, error) {
	if data.Id == "" {
		return nil, mgo.ErrNoId
	}
	_, e := mgo.InsertOne(SchemaMobileAccount, data)
	if e != nil {
		return nil, e
	}
	m := NewMobileAccountWithData(data)
	SetMobileAccount(m)
	return m, nil
}

func NewMobileAccountWithData(data *pb.MobileAccount) *MobileAccount {
	m := &MobileAccount{
		MobileAccount: data,
	}
	return m
}

func (this *MobileAccount) Schema() string {
	return SchemaMobileAccount
}

func (this *MobileAccount) GetVal(key string) any {
	switch key {
	case MobileAccountId:
		return this.Id
	case MobileAccountPassword:
		return this.Password
	case MobileAccountUserId:
		return this.UserId
	default:
		return nil
	}
}

func (this *MobileAccount) Cost() int64 {
	var cost int64 = 0
	cost += int64(len(this.Password))
	cost += int64(len(this.UserId))
	return cost
}

var ()

func SetEmailAccount(m *EmailAccount) {
	mgo.SetModel(m)
}

func DelEmailAccount(id string) {
	m, ok := mgo.GetModel[*EmailAccount](SchemaEmailAccount, id)
	if !ok {
		return
	}
	mgo.DelModel(SchemaEmailAccount, id)
	delEmailAccountMap(m)
}

func onEmailAccountEvict(model mgo.IModel) {
	delEmailAccountMap(model.(*EmailAccount))
}

func delEmailAccountMap(m *EmailAccount) {
}

func GetEmailAccountWithId(id string) (*EmailAccount, error) {
	m, ok := mgo.GetModel[*EmailAccount](SchemaEmailAccount, id)
	if ok {
		return m, nil
	}
	m = _ModelFac[SchemaEmailAccount]().(*EmailAccount)
	err := mgo.FindOne(SchemaEmailAccount, bson.M{"_id": id}, m.EmailAccount)
	if err != nil {
		return nil, err
	}
	SetEmailAccount(m)
	return m, nil
}

type EmailAccount struct {
	*pb.EmailAccount
}

func (this *EmailAccount) SetPassword(val string) {
	this.Password = val
	mgo.ModelWriter().Write(SchemaEmailAccount, this.Id, bson.M{EmailAccountPassword: val})
}

func (this *EmailAccount) SetUserId(val string) {
	this.UserId = val
	mgo.ModelWriter().Write(SchemaEmailAccount, this.Id, bson.M{EmailAccountUserId: val})
}

func NewEmailAccount() mgo.IModel {
	m := &EmailAccount{
		EmailAccount: &pb.EmailAccount{},
	}
	return m
}

func InsertEmailAccount(data *pb.EmailAccount) (*EmailAccount, error) {
	if data.Id == "" {
		return nil, mgo.ErrNoId
	}
	_, e := mgo.InsertOne(SchemaEmailAccount, data)
	if e != nil {
		return nil, e
	}
	m := NewEmailAccountWithData(data)
	SetEmailAccount(m)
	return m, nil
}

func NewEmailAccountWithData(data *pb.EmailAccount) *EmailAccount {
	m := &EmailAccount{
		EmailAccount: data,
	}
	return m
}

func (this *EmailAccount) Schema() string {
	return SchemaEmailAccount
}

func (this *EmailAccount) GetVal(key string) any {
	switch key {
	case EmailAccountId:
		return this.Id
	case EmailAccountPassword:
		return this.Password
	case EmailAccountUserId:
		return this.UserId
	default:
		return nil
	}
}

func (this *EmailAccount) Cost() int64 {
	var cost int64 = 0
	cost += int64(len(this.Password))
	cost += int64(len(this.UserId))
	return cost
}

var ()

func SetWechatAccount(m *WechatAccount) {
	mgo.SetModel(m)
}

func DelWechatAccount(id string) {
	m, ok := mgo.GetModel[*WechatAccount](SchemaWechatAccount, id)
	if !ok {
		return
	}
	mgo.DelModel(SchemaWechatAccount, id)
	delWechatAccountMap(m)
}

func onWechatAccountEvict(model mgo.IModel) {
	delWechatAccountMap(model.(*WechatAccount))
}

func delWechatAccountMap(m *WechatAccount) {
}

func GetWechatAccountWithId(id string) (*WechatAccount, error) {
	m, ok := mgo.GetModel[*WechatAccount](SchemaWechatAccount, id)
	if ok {
		return m, nil
	}
	m = _ModelFac[SchemaWechatAccount]().(*WechatAccount)
	err := mgo.FindOne(SchemaWechatAccount, bson.M{"_id": id}, m.WechatAccount)
	if err != nil {
		return nil, err
	}
	SetWechatAccount(m)
	return m, nil
}

type WechatAccount struct {
	*pb.WechatAccount
}

func (this *WechatAccount) SetUserId(val string) {
	this.UserId = val
	mgo.ModelWriter().Write(SchemaWechatAccount, this.Id, bson.M{WechatAccountUserId: val})
}

func NewWechatAccount() mgo.IModel {
	m := &WechatAccount{
		WechatAccount: &pb.WechatAccount{},
	}
	return m
}

func InsertWechatAccount(data *pb.WechatAccount) (*WechatAccount, error) {
	if data.Id == "" {
		return nil, mgo.ErrNoId
	}
	_, e := mgo.InsertOne(SchemaWechatAccount, data)
	if e != nil {
		return nil, e
	}
	m := NewWechatAccountWithData(data)
	SetWechatAccount(m)
	return m, nil
}

func NewWechatAccountWithData(data *pb.WechatAccount) *WechatAccount {
	m := &WechatAccount{
		WechatAccount: data,
	}
	return m
}

func (this *WechatAccount) Schema() string {
	return SchemaWechatAccount
}

func (this *WechatAccount) GetVal(key string) any {
	switch key {
	case WechatAccountId:
		return this.Id
	case WechatAccountUserId:
		return this.UserId
	default:
		return nil
	}
}

func (this *WechatAccount) Cost() int64 {
	var cost int64 = 0
	cost += int64(len(this.UserId))
	return cost
}

var (
	_UserNickToId  = sync.Map{}
	_UserTokenToId = sync.Map{}
)

func SetUser(m *User) {
	mgo.SetModel(m)
	_UserNickToId.Store(m.Nick, m.Id)
	_UserTokenToId.Store(m.Token, m.Id)
}

func DelUser(id string) {
	m, ok := mgo.GetModel[*User](SchemaUser, id)
	if !ok {
		return
	}
	mgo.DelModel(SchemaUser, id)
	delUserMap(m)
}

func onUserEvict(model mgo.IModel) {
	delUserMap(model.(*User))
}

func delUserMap(m *User) {
	_UserNickToId.Delete(m.Nick)
	_UserTokenToId.Delete(m.Token)
}

func GetUserWithId(id string) (*User, error) {
	m, ok := mgo.GetModel[*User](SchemaUser, id)
	if ok {
		return m, nil
	}
	m = _ModelFac[SchemaUser]().(*User)
	err := mgo.FindOne(SchemaUser, bson.M{"_id": id}, m.User)
	if err != nil {
		return nil, err
	}
	SetUser(m)
	return m, nil
}

func GetUserWithNick(nick string) (*User, error) {
	o, ok := _UserNickToId.Load(nick)
	if ok {
		id := o.(string)
		m, ok := mgo.GetModel[*User](SchemaUser, id)
		if ok {
			return m, nil
		}
	}
	m := _ModelFac[SchemaUser]().(*User)
	err := mgo.FindOne(SchemaUser, bson.M{Nick: nick}, m.Nick)
	if err != nil {
		return nil, err
	}
	SetUser(m)
	return m, nil
}

func GetUserWithToken(token string) (*User, error) {
	o, ok := _UserTokenToId.Load(token)
	if ok {
		id := o.(string)
		m, ok := mgo.GetModel[*User](SchemaUser, id)
		if ok {
			return m, nil
		}
	}
	m := _ModelFac[SchemaUser]().(*User)
	err := mgo.FindOne(SchemaUser, bson.M{Token: token}, m.Token)
	if err != nil {
		return nil, err
	}
	SetUser(m)
	return m, nil
}

type User struct {
	*pb.User
}

func (this *User) SetRoleMask(val int64) {
	this.RoleMask = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{RoleMask: val})
}

func (this *User) SetBan(val bool) {
	this.Ban = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{Ban: val})
}

func (this *User) SetNick(val string) {
	this.Nick = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{Nick: val})
}

func (this *User) SetIdCard(val string) {
	this.IdCard = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{IdCard: val})
}

func (this *User) SetRealName(val string) {
	this.RealName = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{RealName: val})
}

func (this *User) SetCreateTime(val int64) {
	this.CreateTime = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{CreateTime: val})
}

func (this *User) SetLastSignInTime(val int64) {
	this.LastSignInTime = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{LastSignInTime: val})
}

func (this *User) SetLastSignInAddr(val string) {
	this.LastSignInAddr = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{LastSignInAddr: val})
}

func (this *User) SetLastOfflineTime(val int64) {
	this.LastOfflineTime = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{LastOfflineTime: val})
}

func (this *User) SetLastOs(val string) {
	this.LastOs = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{LastOs: val})
}

func (this *User) SetState(val pb.OnlineState) {
	this.State = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{State: val})
}

func (this *User) SetAvatar(val string) {
	this.Avatar = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{Avatar: val})
}

func (this *User) SetToken(val string) {
	this.Token = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{Token: val})
}

func (this *User) SetHead(val []byte) {
	this.Head = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{Head: val})
}

func (this *User) SetOnlineDur(val int64) {
	this.OnlineDur = val
	mgo.ModelWriter().Write(SchemaUser, this.Id, bson.M{OnlineDur: val})
}

func NewUser() mgo.IModel {
	m := &User{
		User: &pb.User{},
	}
	return m
}

func InsertUser(data *pb.User) (*User, error) {
	if data.Id == "" {
		return nil, mgo.ErrNoId
	}
	_, e := mgo.InsertOne(SchemaUser, data)
	if e != nil {
		return nil, e
	}
	m := NewUserWithData(data)
	SetUser(m)
	return m, nil
}

func NewUserWithData(data *pb.User) *User {
	m := &User{
		User: data,
	}
	return m
}

func (this *User) Schema() string {
	return SchemaUser
}

func (this *User) GetVal(key string) any {
	switch key {
	case Id:
		return this.Id
	case RoleMask:
		return this.RoleMask
	case Ban:
		return this.Ban
	case Nick:
		return this.Nick
	case IdCard:
		return this.IdCard
	case RealName:
		return this.RealName
	case CreateTime:
		return this.CreateTime
	case LastSignInTime:
		return this.LastSignInTime
	case LastSignInAddr:
		return this.LastSignInAddr
	case LastOfflineTime:
		return this.LastOfflineTime
	case LastOs:
		return this.LastOs
	case State:
		return this.State
	case Avatar:
		return this.Avatar
	case Token:
		return this.Token
	case Head:
		return this.Head
	case OnlineDur:
		return this.OnlineDur
	default:
		return nil
	}
}

func (this *User) CopyPlayerTag(m *pb.User) {
	m.Id = this.Id
	m.RoleMask = this.RoleMask
	m.Nick = this.Nick
	m.State = this.State
	m.Avatar = this.Avatar
}

func (this *User) Cost() int64 {
	var cost int64 = 0
	cost += 8 //RoleMask int64
	cost += 1 //Ban bool
	cost += int64(len(this.Nick))
	cost += int64(len(this.IdCard))
	cost += int64(len(this.RealName))
	cost += 8 //CreateTime int64
	cost += 8 //LastSignInTime int64
	cost += int64(len(this.LastSignInAddr))
	cost += 8 //LastOfflineTime int64
	cost += int64(len(this.LastOs))
	cost += 4 //State enum
	cost += int64(len(this.Avatar))
	cost += int64(len(this.Token))
	cost += int64(len(this.Head))
	cost += 8 //OnlineDur int64
	return cost
}
