// Code generated by protoc-gen-go-kiwi. DO NOT EDIT.

package user

import (
	"game/proto/pb"
	"github.com/15mga/kiwi/util/mgo"
	"go.mongodb.org/mongo-driver/bson"
)

func initModels() {
	initModelFac()
	initEvict()
}

var _ModelFac map[string]func() mgo.IModel

func initModelFac() {
	_ModelFac = map[string]func() mgo.IModel{
		SchemaMobileAccount: NewMobileAccount,
		SchemaEmailAccount:  NewEmailAccount,
		SchemaWechatAccount: NewWechatAccount,
		SchemaUser:          NewUser,
	}
}

func initEvict() {
	mgo.BindEvict(SchemaMobileAccount, onMobileAccountEvict)
	mgo.BindEvict(SchemaEmailAccount, onEmailAccountEvict)
	mgo.BindEvict(SchemaWechatAccount, onWechatAccountEvict)
	mgo.BindEvict(SchemaUser, onUserEvict)
}

var (
	_MobileAccountIdMap = make(map[string]struct{})
)

func StoreAllMobileAccounts() {
	for id := range _MobileAccountIdMap {
		m, ok := mgo.Get[*MobileAccount](SchemaMobileAccount, id)
		if !ok {
			continue
		}
		m.Store()
	}
}

func SetMobileAccount(m *MobileAccount) {
	mgo.Set(m)
}

func DelMobileAccount(id string) {
	m, ok := mgo.Get[*MobileAccount](SchemaMobileAccount, id)
	if !ok {
		return
	}
	_ = m.Store()
	mgo.Del(SchemaMobileAccount, id)
	delMobileAccountMap(m)
}

func onMobileAccountEvict(model mgo.IModel) {
	m := model.(*MobileAccount)
	_ = m.Store()
	delMobileAccountMap(m)
}

func delMobileAccountMap(m *MobileAccount) {
	delete(_MobileAccountIdMap, m.GetId())
}

func GetMobileAccountWithId(id string) (*MobileAccount, error) {
	m, ok := mgo.Get[*MobileAccount](SchemaMobileAccount, id)
	if ok {
		return m, nil
	}
	m = _ModelFac[SchemaMobileAccount]().(*MobileAccount)
	err := m.Load(id, m.MobileAccount)
	if err != nil {
		return nil, err
	}
	SetMobileAccount(m)
	return m, nil
}

type MobileAccount struct {
	*pb.MobileAccount
	*mgo.Model
}

func (this *MobileAccount) SetPassword(val string) {
	this.Password = val
	this.SetDirty(MobileAccountPassword)
}

func (this *MobileAccount) SetUserId(val string) {
	this.UserId = val
	this.SetDirty(MobileAccountUserId)
}

func NewMobileAccount() mgo.IModel {
	m := &MobileAccount{
		MobileAccount: &pb.MobileAccount{},
	}
	m.Model = mgo.NewModel(SchemaMobileAccount, 3, m.GetVal)
	return m
}

func InsertMobileAccount(data *pb.MobileAccount) (*MobileAccount, error) {
	if data.Id == "" {
		return nil, mgo.ErrNoId
	}
	_, e := mgo.InsertOne(SchemaMobileAccount, data)
	if e != nil {
		return nil, e
	}
	m := NewMobileAccountWithData(data)
	SetMobileAccount(m)
	return m, nil
}

func NewMobileAccountWithData(data *pb.MobileAccount) *MobileAccount {
	m := &MobileAccount{
		MobileAccount: data,
	}
	m.Model = mgo.NewModel(SchemaMobileAccount, 3, m.GetVal)
	m.SetDirty(
		MobileAccountPassword,
		MobileAccountUserId,
	)
	return m
}

func (this *MobileAccount) GetVal(key string) any {
	switch key {
	default:
		return nil
	}
}

func (this *MobileAccount) Cost() int64 {
	var cost int64 = 0
	cost += int64(len(this.Password))
	cost += int64(len(this.UserId))
	return cost
}

var (
	_EmailAccountIdMap = make(map[string]struct{})
)

func StoreAllEmailAccounts() {
	for id := range _EmailAccountIdMap {
		m, ok := mgo.Get[*EmailAccount](SchemaEmailAccount, id)
		if !ok {
			continue
		}
		m.Store()
	}
}

func SetEmailAccount(m *EmailAccount) {
	mgo.Set(m)
}

func DelEmailAccount(id string) {
	m, ok := mgo.Get[*EmailAccount](SchemaEmailAccount, id)
	if !ok {
		return
	}
	_ = m.Store()
	mgo.Del(SchemaEmailAccount, id)
	delEmailAccountMap(m)
}

func onEmailAccountEvict(model mgo.IModel) {
	m := model.(*EmailAccount)
	_ = m.Store()
	delEmailAccountMap(m)
}

func delEmailAccountMap(m *EmailAccount) {
	delete(_EmailAccountIdMap, m.GetId())
}

func GetEmailAccountWithId(id string) (*EmailAccount, error) {
	m, ok := mgo.Get[*EmailAccount](SchemaEmailAccount, id)
	if ok {
		return m, nil
	}
	m = _ModelFac[SchemaEmailAccount]().(*EmailAccount)
	err := m.Load(id, m.EmailAccount)
	if err != nil {
		return nil, err
	}
	SetEmailAccount(m)
	return m, nil
}

type EmailAccount struct {
	*pb.EmailAccount
	*mgo.Model
}

func (this *EmailAccount) SetPassword(val string) {
	this.Password = val
	this.SetDirty(EmailAccountPassword)
}

func (this *EmailAccount) SetUserId(val string) {
	this.UserId = val
	this.SetDirty(EmailAccountUserId)
}

func NewEmailAccount() mgo.IModel {
	m := &EmailAccount{
		EmailAccount: &pb.EmailAccount{},
	}
	m.Model = mgo.NewModel(SchemaEmailAccount, 3, m.GetVal)
	return m
}

func InsertEmailAccount(data *pb.EmailAccount) (*EmailAccount, error) {
	if data.Id == "" {
		return nil, mgo.ErrNoId
	}
	_, e := mgo.InsertOne(SchemaEmailAccount, data)
	if e != nil {
		return nil, e
	}
	m := NewEmailAccountWithData(data)
	SetEmailAccount(m)
	return m, nil
}

func NewEmailAccountWithData(data *pb.EmailAccount) *EmailAccount {
	m := &EmailAccount{
		EmailAccount: data,
	}
	m.Model = mgo.NewModel(SchemaEmailAccount, 3, m.GetVal)
	m.SetDirty(
		EmailAccountPassword,
		EmailAccountUserId,
	)
	return m
}

func (this *EmailAccount) GetVal(key string) any {
	switch key {
	default:
		return nil
	}
}

func (this *EmailAccount) Cost() int64 {
	var cost int64 = 0
	cost += int64(len(this.Password))
	cost += int64(len(this.UserId))
	return cost
}

var (
	_WechatAccountIdMap = make(map[string]struct{})
)

func StoreAllWechatAccounts() {
	for id := range _WechatAccountIdMap {
		m, ok := mgo.Get[*WechatAccount](SchemaWechatAccount, id)
		if !ok {
			continue
		}
		m.Store()
	}
}

func SetWechatAccount(m *WechatAccount) {
	mgo.Set(m)
}

func DelWechatAccount(id string) {
	m, ok := mgo.Get[*WechatAccount](SchemaWechatAccount, id)
	if !ok {
		return
	}
	_ = m.Store()
	mgo.Del(SchemaWechatAccount, id)
	delWechatAccountMap(m)
}

func onWechatAccountEvict(model mgo.IModel) {
	m := model.(*WechatAccount)
	_ = m.Store()
	delWechatAccountMap(m)
}

func delWechatAccountMap(m *WechatAccount) {
	delete(_WechatAccountIdMap, m.GetId())
}

func GetWechatAccountWithId(id string) (*WechatAccount, error) {
	m, ok := mgo.Get[*WechatAccount](SchemaWechatAccount, id)
	if ok {
		return m, nil
	}
	m = _ModelFac[SchemaWechatAccount]().(*WechatAccount)
	err := m.Load(id, m.WechatAccount)
	if err != nil {
		return nil, err
	}
	SetWechatAccount(m)
	return m, nil
}

type WechatAccount struct {
	*pb.WechatAccount
	*mgo.Model
}

func (this *WechatAccount) SetUserId(val string) {
	this.UserId = val
	this.SetDirty(WechatAccountUserId)
}

func NewWechatAccount() mgo.IModel {
	m := &WechatAccount{
		WechatAccount: &pb.WechatAccount{},
	}
	m.Model = mgo.NewModel(SchemaWechatAccount, 2, m.GetVal)
	return m
}

func InsertWechatAccount(data *pb.WechatAccount) (*WechatAccount, error) {
	if data.Id == "" {
		return nil, mgo.ErrNoId
	}
	_, e := mgo.InsertOne(SchemaWechatAccount, data)
	if e != nil {
		return nil, e
	}
	m := NewWechatAccountWithData(data)
	SetWechatAccount(m)
	return m, nil
}

func NewWechatAccountWithData(data *pb.WechatAccount) *WechatAccount {
	m := &WechatAccount{
		WechatAccount: data,
	}
	m.Model = mgo.NewModel(SchemaWechatAccount, 2, m.GetVal)
	m.SetDirty(
		WechatAccountUserId,
	)
	return m
}

func (this *WechatAccount) GetVal(key string) any {
	switch key {
	default:
		return nil
	}
}

func (this *WechatAccount) Cost() int64 {
	var cost int64 = 0
	cost += int64(len(this.UserId))
	return cost
}

var (
	_UserIdMap     = make(map[string]struct{})
	_UserNickToId  = make(map[string]string)
	_UserTokenToId = make(map[string]string)
)

func StoreAllUsers() {
	for id := range _UserIdMap {
		m, ok := mgo.Get[*User](SchemaUser, id)
		if !ok {
			continue
		}
		m.Store()
	}
}

func SetUser(m *User) {
	mgo.Set(m)
	_UserNickToId[m.Nick] = m.Id
	_UserTokenToId[m.Token] = m.Id
}

func DelUser(id string) {
	m, ok := mgo.Get[*User](SchemaUser, id)
	if !ok {
		return
	}
	_ = m.Store()
	mgo.Del(SchemaUser, id)
	delUserMap(m)
}

func onUserEvict(model mgo.IModel) {
	m := model.(*User)
	_ = m.Store()
	delUserMap(m)
}

func delUserMap(m *User) {
	delete(_UserIdMap, m.GetId())
	delete(_UserNickToId, m.Nick)
	delete(_UserTokenToId, m.Token)
}

func GetUserWithId(id string) (*User, error) {
	m, ok := mgo.Get[*User](SchemaUser, id)
	if ok {
		return m, nil
	}
	m = _ModelFac[SchemaUser]().(*User)
	err := m.Load(id, m.User)
	if err != nil {
		return nil, err
	}
	SetUser(m)
	return m, nil
}

func GetUserWithNick(nick string) (*User, error) {
	id, ok := _UserNickToId[nick]
	if ok {
		m, ok := mgo.Get[*User](SchemaUser, id)
		if ok {
			return m, nil
		}
	}
	m := _ModelFac[SchemaUser]().(*User)
	err := m.LoadWithFilter(bson.M{Nick: nick})
	if err != nil {
		return nil, err
	}
	SetUser(m)
	return m, nil
}

func GetUserWithToken(token string) (*User, error) {
	id, ok := _UserTokenToId[token]
	if ok {
		m, ok := mgo.Get[*User](SchemaUser, id)
		if ok {
			return m, nil
		}
	}
	m := _ModelFac[SchemaUser]().(*User)
	err := m.LoadWithFilter(bson.M{Token: token})
	if err != nil {
		return nil, err
	}
	SetUser(m)
	return m, nil
}

type User struct {
	*pb.User
	*mgo.Model
}

func (this *User) SetRoleMask(val int64) {
	this.RoleMask = val
	this.SetDirty(RoleMask)
}

func (this *User) SetBan(val bool) {
	this.Ban = val
	this.SetDirty(Ban)
}

func (this *User) SetNick(val string) {
	this.Nick = val
	this.SetDirty(Nick)
}

func (this *User) SetIdCard(val string) {
	this.IdCard = val
	this.SetDirty(IdCard)
}

func (this *User) SetRealName(val string) {
	this.RealName = val
	this.SetDirty(RealName)
}

func (this *User) SetCreateTime(val int64) {
	this.CreateTime = val
	this.SetDirty(CreateTime)
}

func (this *User) SetLastSignInTime(val int64) {
	this.LastSignInTime = val
	this.SetDirty(LastSignInTime)
}

func (this *User) SetLastSignInAddr(val string) {
	this.LastSignInAddr = val
	this.SetDirty(LastSignInAddr)
}

func (this *User) SetLastOfflineTime(val int64) {
	this.LastOfflineTime = val
	this.SetDirty(LastOfflineTime)
}

func (this *User) SetLastOs(val string) {
	this.LastOs = val
	this.SetDirty(LastOs)
}

func (this *User) SetState(val pb.OnlineState) {
	this.State = val
	this.SetDirty(State)
}

func (this *User) SetAvatar(val string) {
	this.Avatar = val
	this.SetDirty(Avatar)
}

func (this *User) SetToken(val string) {
	this.Token = val
	this.SetDirty(Token)
}

func (this *User) SetHead(val []byte) {
	this.Head = val
	this.SetDirty(Head)
}

func (this *User) SetOnlineDur(val int64) {
	this.OnlineDur = val
	this.SetDirty(OnlineDur)
}

func NewUser() mgo.IModel {
	m := &User{
		User: &pb.User{},
	}
	m.Model = mgo.NewModel(SchemaUser, 16, m.GetVal)
	return m
}

func InsertUser(data *pb.User) (*User, error) {
	if data.Id == "" {
		return nil, mgo.ErrNoId
	}
	_, e := mgo.InsertOne(SchemaUser, data)
	if e != nil {
		return nil, e
	}
	m := NewUserWithData(data)
	SetUser(m)
	return m, nil
}

func NewUserWithData(data *pb.User) *User {
	m := &User{
		User: data,
	}
	m.Model = mgo.NewModel(SchemaUser, 16, m.GetVal)
	m.SetDirty(
		RoleMask,
		Ban,
		Nick,
		IdCard,
		RealName,
		CreateTime,
		LastSignInTime,
		LastSignInAddr,
		LastOfflineTime,
		LastOs,
		State,
		Avatar,
		Token,
		Head,
		OnlineDur,
	)
	return m
}

func (this *User) GetVal(key string) any {
	switch key {
	default:
		return nil
	}
}

func (this *User) Cost() int64 {
	var cost int64 = 0
	cost += 8 //RoleMask int64
	cost += 1 //Ban bool
	cost += int64(len(this.Nick))
	cost += int64(len(this.IdCard))
	cost += int64(len(this.RealName))
	cost += 8 //CreateTime int64
	cost += 8 //LastSignInTime int64
	cost += int64(len(this.LastSignInAddr))
	cost += 8 //LastOfflineTime int64
	cost += int64(len(this.LastOs))
	cost += 4 //State enum
	cost += int64(len(this.Avatar))
	cost += int64(len(this.Token))
	cost += int64(len(this.Head))
	cost += 8 //OnlineDur int64
	return cost
}
